import{_ as i,c as a,a2 as l,o as t}from"./chunks/framework.BQmytedh.js";const d=JSON.parse('{"title":"JavaScript 事件循环 (Event Loop)","description":"","frontmatter":{},"headers":[],"relativePath":"js/evenloop.md","filePath":"js/evenloop.md","lastUpdated":null}'),n={name:"js/evenloop.md"};function e(h,s,p,k,r,o){return t(),a("div",null,s[0]||(s[0]=[l(`<h1 id="javascript-事件循环-event-loop" tabindex="-1">JavaScript 事件循环 (Event Loop) <a class="header-anchor" href="#javascript-事件循环-event-loop" aria-label="Permalink to &quot;JavaScript 事件循环 (Event Loop)&quot;">​</a></h1><h2 id="什么是事件循环" tabindex="-1">什么是事件循环？ <a class="header-anchor" href="#什么是事件循环" aria-label="Permalink to &quot;什么是事件循环？&quot;">​</a></h2><p>事件循环是 JavaScript 实现异步编程的核心机制。JavaScript 是单线程的语言，但通过事件循环机制可以实现非阻塞的异步执行。</p><h2 id="事件循环的核心组成部分" tabindex="-1">事件循环的核心组成部分 <a class="header-anchor" href="#事件循环的核心组成部分" aria-label="Permalink to &quot;事件循环的核心组成部分&quot;">​</a></h2><ol><li><p><strong>调用栈 (Call Stack)</strong></p><ul><li>用于存储正在执行的代码</li><li>遵循后进先出(LIFO)原则</li><li>同步代码直接在这里执行</li></ul></li><li><p><strong>任务队列 (Task Queue)</strong></p><ul><li>宏任务(Macrotask)队列</li><li>微任务(Microtask)队列</li></ul></li><li><p><strong>Web APIs</strong></p><ul><li>由浏览器提供的 API</li><li>包括定时器、DOM 事件、AJAX 等</li></ul></li></ol><h2 id="事件循环的执行顺序" tabindex="-1">事件循环的执行顺序 <a class="header-anchor" href="#事件循环的执行顺序" aria-label="Permalink to &quot;事件循环的执行顺序&quot;">​</a></h2><ol><li>先执行一个宏任务，执行过程中如果产出新的宏/微任务，就将他们推入相应的任务队列， 2.之后在执行一队微任务， 3.之后再执行宏任务，如此循环。 以上不断重复的过程就叫做 Event Loop(事件循环)。</li></ol><h2 id="宏任务和微任务" tabindex="-1">宏任务和微任务 <a class="header-anchor" href="#宏任务和微任务" aria-label="Permalink to &quot;宏任务和微任务&quot;">​</a></h2><p>如何区分两者？宿主运行环境发起的就是<code>宏任务</code>，如由node/浏览器发起的的setTimeout/setInterval; 由语言标准内api发起的就是<code>微任务</code>，如：Promise.then/catch/finally;</p><h3 id="宏任务-macrotask" tabindex="-1">宏任务 (Macrotask) <a class="header-anchor" href="#宏任务-macrotask" aria-label="Permalink to &quot;宏任务 (Macrotask)&quot;">​</a></h3><ul><li>script内的整体代码</li><li>setTimeout/setInterval</li><li>setImmediate (Node.js)</li><li>requestAnimationFrame</li><li>I/O</li><li>UI 渲染</li></ul><h3 id="微任务-microtask" tabindex="-1">微任务 (Microtask) <a class="header-anchor" href="#微任务-microtask" aria-label="Permalink to &quot;微任务 (Microtask)&quot;">​</a></h3><ul><li>Promise.then/catch/finally</li><li>process.nextTick (Node.js)</li><li>MutationObserver</li><li>queueMicrotask()</li></ul><h2 id="代码示例" tabindex="-1">代码示例 <a class="header-anchor" href="#代码示例" aria-label="Permalink to &quot;代码示例&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setTimeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;promise1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;promise2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script end&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// script start, script end, promise1, promise2, setTimeout</span></span></code></pre></div><blockquote><p>在一次宏任务执行完成后，会先执行微任务队列，直至清空所有微任务队列，然后执行宏任务</p></blockquote>`,16)]))}const c=i(n,[["render",e]]);export{d as __pageData,c as default};
