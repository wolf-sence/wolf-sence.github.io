import{_ as t,c as a,o as l,ag as o}from"./chunks/framework.DPDPlp3K.js";const h=JSON.parse('{"title":"js线程与渲染线程","description":"","frontmatter":{},"headers":[],"relativePath":"document/useless/js/thread.md","filePath":"document/useless/js/thread.md","lastUpdated":1744303628000}'),s={name:"document/useless/js/thread.md"};function i(r,e,n,d,c,p){return l(),a("div",null,e[0]||(e[0]=[o('<h1 id="js线程与渲染线程" tabindex="-1">js线程与渲染线程 <a class="header-anchor" href="#js线程与渲染线程" aria-label="Permalink to &quot;js线程与渲染线程&quot;">​</a></h1><p>一个进程可以包含多个线程，而在浏览器中就会存在多个线程，包括js线程与渲染线程</p><h2 id="互斥关系" tabindex="-1">互斥关系 <a class="header-anchor" href="#互斥关系" aria-label="Permalink to &quot;互斥关系&quot;">​</a></h2><ul><li>当js执行与核心渲染(layout/style/paint)在运行时，两者是互斥的，两者在同一个进程中完成，共享同一个事件循环队列</li></ul><blockquote><p>这也是为什么长时间运行的 JavaScript 会阻塞渲染，导致页面卡顿、无响应（因为浏览器无法更新画面，也无法响应用户输入）。浏览器需要等待 JS 执行完毕，才能继续处理后续的渲染任务或用户事件</p></blockquote><ul><li>当渲染进入合成时, 即使主线程在执行 JavaScript（只要不是阻塞时间过长），合成器线程仍然可以在后台工作，处理滚动或者那些只影响合成的 CSS 动画，这就是为什么这类动画通常更流畅。</li></ul><blockquote><p>合成器线程负责将这些已经绘制好的层（位图）组合起来，最终显示在屏幕上。它还可以独立于主线程处理一些简单的变换，</p></blockquote><p>当js在webworker执行时，他是独立于主线程的，所以可以同步进行</p><h2 id="当修改发生时" tabindex="-1">当修改发生时 <a class="header-anchor" href="#当修改发生时" aria-label="Permalink to &quot;当修改发生时&quot;">​</a></h2><p>当使用js修改某个dom时，<em>渲染引擎并不会立刻停下所有工作并执行重排（Reflow/Layout）或重绘（Repaint）</em>，他会将改动的元素标记为脏</p><p>此时剩下的js继续执行，当执行权交给事件循环时，浏览器会决定是否启动渲染进程进行渲染更新</p><h2 id="强制同步布局" tabindex="-1">强制同步布局 <a class="header-anchor" href="#强制同步布局" aria-label="Permalink to &quot;强制同步布局&quot;">​</a></h2><p>有一种例外的情况是，后续的 JavaScript 代码试图读取一个需要最新布局信息才能准确返回的属性（例如 element.offsetHeight, element.offsetTop, element.clientWidth, getComputedStyle(element).width, element.getBoundingClientRect().width 等），浏览器会被强制：</p><ul><li>立刻停止当前的 JS 执行。</li><li>同步地执行所有挂起的样式计算和布局（重排）任务，就在此时此地完成计算。</li><li>然后将计算得到的、准确的属性值返回给您的 JS 代码。</li><li>最后，恢复 JS 代码从刚才停下的地方继续执行。 在这种场景下，渲染计算会打断js进程的执行</li></ul>',14)]))}const m=t(s,[["render",i]]);export{h as __pageData,m as default};
