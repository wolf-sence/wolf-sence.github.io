import{_ as a,c as r,o as t,ag as o}from"./chunks/framework.DPDPlp3K.js";const u=JSON.parse('{"title":"页面白屏问题","description":"","frontmatter":{},"headers":[],"relativePath":"document/useless/js/white.md","filePath":"document/useless/js/white.md","lastUpdated":1743353941000}'),l={name:"document/useless/js/white.md"};function i(n,e,s,h,d,c){return t(),r("div",null,e[0]||(e[0]=[o('<h1 id="页面白屏问题" tabindex="-1">页面白屏问题 <a class="header-anchor" href="#页面白屏问题" aria-label="Permalink to &quot;页面白屏问题&quot;">​</a></h1><h2 id="白屏检测" tabindex="-1">白屏检测 <a class="header-anchor" href="#白屏检测" aria-label="Permalink to &quot;白屏检测&quot;">​</a></h2><h3 id="取样法" tabindex="-1">取样法 <a class="header-anchor" href="#取样法" aria-label="Permalink to &quot;取样法&quot;">​</a></h3><p>于页面中设置多个（17）采样点,基于<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint" target="_blank" rel="noreferrer">elementsFromPoint</a>获取该点的所有元素的数组，元素从视口到最底层排序，判断到底有没有内容</p><blockquote><p>可以看看这个库：<a href="https://github.com/xy-sea/web-see" target="_blank" rel="noreferrer">web-see</a></p></blockquote><p>这里针对骨架屏也能跟好的判断，根据采样点的元素来判断是否为骨架屏元素</p><h3 id="mutation-observer监控dom变化" tabindex="-1">Mutation Observer监控dom变化 <a class="header-anchor" href="#mutation-observer监控dom变化" aria-label="Permalink to &quot;Mutation Observer监控dom变化&quot;">​</a></h3><p>通过Mutation Observer来监控html下根节点内新增dom节点的变化来判断是否进行来正常的渲染</p><p>不好完美判断，根节点下有dom也有可能是白屏</p><h3 id="onerror" tabindex="-1">onerror <a class="header-anchor" href="#onerror" aria-label="Permalink to &quot;onerror&quot;">​</a></h3><p>使用<code>window.onerror</code>来监听js执行错误</p><h3 id="检测根节点" tabindex="-1">检测根节点 <a class="header-anchor" href="#检测根节点" aria-label="Permalink to &quot;检测根节点&quot;">​</a></h3><p>在基于spa引用下，可以检测根节点来判断是否加载内容</p><h3 id="截图检测" tabindex="-1">截图检测 <a class="header-anchor" href="#截图检测" aria-label="Permalink to &quot;截图检测&quot;">​</a></h3><p>使用canvas实现前端截屏，然后将图片与纯白图片对比查看相似度，从而对比是否白屏</p><p>性能不高，通用性差，骨架屏不好处理</p><h2 id="如何排查" tabindex="-1">如何排查 <a class="header-anchor" href="#如何排查" aria-label="Permalink to &quot;如何排查&quot;">​</a></h2><h3 id="请求" tabindex="-1">请求 <a class="header-anchor" href="#请求" aria-label="Permalink to &quot;请求&quot;">​</a></h3><p>现在初始化的url请求，返回的html文件是否正常，是否包含符合预期的内容，例如内置的script标签、css标签， 这一步有可能会遇到初始化的url请求就是挂的，html没返回，这里基本可以判断是资源服务挂掉了</p><p>而服务挂掉的情况也有多种，</p><ul><li>有可能是线上路由没有配置导致没有html资源</li><li>有可能是nginx没有配好导致请求进不来</li><li>有可能是公司内部配置平台的url转发规则对不上</li><li>有可能是ssr服务端运行出错导致请求出错</li></ul><h3 id="资源" tabindex="-1">资源 <a class="header-anchor" href="#资源" aria-label="Permalink to &quot;资源&quot;">​</a></h3><p>查看页面的白屏html中是否有dom元素以及配合查看js资源的请求加载情况，以此判断初步判断出错的阶段， 如只有一个根节点、或者是空节点，即可能是script资源进不来， 可能是cdn资源挂了或者对应的静态资源服务挂了，这里可以配合浏览器的network面板去看资源的请求状态</p><h3 id="加载速度" tabindex="-1">加载速度 <a class="header-anchor" href="#加载速度" aria-label="Permalink to &quot;加载速度&quot;">​</a></h3><p>如果资源加载正常，则要区分是代码执行报错阻塞了浏览器渲染还是仅仅只是加载太慢</p><h3 id="控制台报错" tabindex="-1">控制台报错 <a class="header-anchor" href="#控制台报错" aria-label="Permalink to &quot;控制台报错&quot;">​</a></h3><p>如果资源正常返回，但dom依旧为空，可以初步判断为js逻辑错误导致加载中断，可以看看控制台是否有报错信息</p><p>生产环境代码被压缩后，可以依靠源代码打包堆栈信息结合sourcemap来定位出错的源代码位置</p><p>如果没有提前准备好sourcemap，则需要依靠源码逐步去找代码，比较方便的方式还是找常量</p>',29)]))}const m=a(l,[["render",i]]);export{u as __pageData,m as default};
