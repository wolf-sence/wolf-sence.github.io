import{_ as i,c as a,o as e,ag as l}from"./chunks/framework.DPDPlp3K.js";const o=JSON.parse('{"title":"vue2/3响应式原理介绍","description":"","frontmatter":{},"headers":[],"relativePath":"document/useless/vue/Responsive.md","filePath":"document/useless/vue/Responsive.md","lastUpdated":1743355575000}'),t={name:"document/useless/vue/Responsive.md"};function n(h,s,p,k,r,E){return e(),a("div",null,s[0]||(s[0]=[l(`<h1 id="vue2-3响应式原理介绍" tabindex="-1">vue2/3响应式原理介绍 <a class="header-anchor" href="#vue2-3响应式原理介绍" aria-label="Permalink to &quot;vue2/3响应式原理介绍&quot;">​</a></h1><h2 id="vue2" tabindex="-1">vue2 <a class="header-anchor" href="#vue2" aria-label="Permalink to &quot;vue2&quot;">​</a></h2><p>Vue 2 的响应式系统基于 ES5 的 Object.defineProperty，通过 getter 和 setter 拦截对象的属性访问和修改。</p><h3 id="数据劫持" tabindex="-1">数据劫持 <a class="header-anchor" href="#数据劫持" aria-label="Permalink to &quot;数据劫持&quot;">​</a></h3><p>Vue 2 在初始化时，会遍历 data 对象的所有属性，使用 Object.defineProperty 为每个属性定义 getter 和 setter。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { msg: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;msg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Getter called&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._msg;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Setter called&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._msg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 触发更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="依赖收集" tabindex="-1">依赖收集 <a class="header-anchor" href="#依赖收集" aria-label="Permalink to &quot;依赖收集&quot;">​</a></h3><ul><li>Watcher：每个组件有一个 Watcher 实例，负责更新视图。</li><li>Dep：每个响应式属性都有一个 Dep 对象（依赖管理器），用来存储依赖它的 Watcher。</li><li>当组件渲染时，访问数据属性会触发 getter，getter 会把当前 Watcher 收集到属性的 Dep 中（称为“订阅”）。</li></ul><h3 id="派发更新" tabindex="-1">派发更新 <a class="header-anchor" href="#派发更新" aria-label="Permalink to &quot;派发更新&quot;">​</a></h3><ul><li>当属性值被修改时，触发 setter，setter 调用 Dep.notify() 通知所有订阅的 Watcher。</li><li>Watcher 收到通知后，重新执行渲染函数，更新视图。</li></ul><h3 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-label="Permalink to &quot;优缺点&quot;">​</a></h3><p>优点</p><ul><li>简单直接，基于成熟的 ES5 API。</li><li>兼容性好，支持旧浏览器。</li></ul><p>缺点</p><ul><li>无法检测对象属性新增/删除：Object.defineProperty只能劫持已有属性，动态添加属性（如 obj.newProp = 1）或删除属性（如 delete obj.prop）不会触发响应式。</li></ul><ul><li><ul><li>解决办法：Vue 提供了 Vue.set 和 Vue.delete。</li></ul></li></ul><ul><li>数组问题：数组的某些方法（如 push、pop）不会触发 setter，</li></ul><ul><li><ul><li>Vue 通过重写数组方法解决。 示例：arr.push(1) 调用的是 Vue 改写的 push，内部调用 setter。</li></ul></li></ul><ul><li>性能开销：递归遍历所有嵌套对象，初始化时性能消耗较大。</li></ul><h2 id="vue3" tabindex="-1">vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;vue3&quot;">​</a></h2><p>Vue 3 引入了 ES6 的 Proxy，完全重写了响应式系统，解决了 Vue 2 的局限性，并提升了性能和灵活性。</p><h3 id="proxy代理" tabindex="-1">proxy代理 <a class="header-anchor" href="#proxy代理" aria-label="Permalink to &quot;proxy代理&quot;">​</a></h3><ul><li>Vue 3 使用 Proxy 代理整个对象，而不是单独为每个属性定义 getter/setter。</li><li>Proxy 可以拦截对象的各种操作（如属性访问、赋值、删除、添加等）。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { msg: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> reactiveData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Get&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target[key];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Set&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key, value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    target[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 触发更新</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="依赖收集effect" tabindex="-1">依赖收集Effect <a class="header-anchor" href="#依赖收集effect" aria-label="Permalink to &quot;依赖收集Effect&quot;">​</a></h3><ul><li>Vue 3 使用 ReactiveEffect 类代替 Watcher，管理副作用（effect，如渲染函数）。</li><li>通过 track 函数收集依赖，trigger 函数派发更新。</li><li>每个属性通过 Map 和 Set 结构存储依赖。</li></ul><h3 id="懒收集" tabindex="-1">懒收集 <a class="header-anchor" href="#懒收集" aria-label="Permalink to &quot;懒收集&quot;">​</a></h3><p>依赖只在属性被访问时收集，未使用的属性不会触发响应式，提升性能。</p><h3 id="优缺点-1" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点-1" aria-label="Permalink to &quot;优缺点&quot;">​</a></h3><p>优点</p><ul><li>支持属性新增/删除：Proxy 能拦截 in、delete 等操作，动态添加或删除属性也能触发响应式。</li><li>数组完美支持：无需重写数组方法，直接拦截数组操作（如 arr[0] = 1 或 arr.length）。</li><li>性能优化：只代理顶层对象，不递归遍历所有属性。懒收集依赖，未访问的属性不触发响应式。</li><li>类型支持：支持 Map、Set 等集合类型（通过 reactive 或 ref）。</li></ul><p>局限性</p><ul><li>兼容性：依赖 ES6 的 Proxy，不支持 IE。</li><li>复杂性：内部实现更复杂，调试可能稍难。</li></ul>`,33)]))}const u=i(t,[["render",n]]);export{o as __pageData,u as default};
