import{_ as l,c as e,o as i,ag as t}from"./chunks/framework.DPDPlp3K.js";const p=JSON.parse('{"title":"垃圾回收","description":"","frontmatter":{},"headers":[],"relativePath":"document/useless/js/gc.md","filePath":"document/useless/js/gc.md","lastUpdated":1744044433000}'),o={name:"document/useless/js/gc.md"};function r(s,a,c,n,d,h){return i(),e("div",null,a[0]||(a[0]=[t('<h1 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h1><p>javascript垃圾回收的核心是标记清除</p><h2 id="常见的gc算法" tabindex="-1">常见的GC算法 <a class="header-anchor" href="#常见的gc算法" aria-label="Permalink to &quot;常见的GC算法&quot;">​</a></h2><h3 id="引用计数法" tabindex="-1">引用计数法 <a class="header-anchor" href="#引用计数法" aria-label="Permalink to &quot;引用计数法&quot;">​</a></h3><p>由对象自己记录下有多少程序在引用自己，当引用数清零的时候，即意味着GC回收</p><p>优点</p><ul><li>即时回收，当引用为0时就会把对象连向空闲链表等待回收；</li><li>不用遍历堆区活动对象和非活动对象 缺点</li><li>无法解决循环引用；（两个对象或多个形成引用环，引用计数不为0故无法回收）</li><li>每个对象都要有引用计数器，内存开销大；</li></ul><blockquote><p>该算法已经逐渐被 ‘标记-清除’ 算法替代，在V8引擎里面，使用最多的就是 标记-清除算法</p></blockquote><h3 id="标记清除法-这也是js现在使用的算法" tabindex="-1">标记清除法-这也是js现在使用的算法 <a class="header-anchor" href="#标记清除法-这也是js现在使用的算法" aria-label="Permalink to &quot;标记清除法-这也是js现在使用的算法&quot;">​</a></h3><p>垃圾回收器从一些固定的“根”开始，比如全局对象（在浏览器中是 window，在 Node.js 中是 global）、当前执行上下文的变量等，通过区分引用链（比如对象的属性、数组的元素）能访问到的对象，分为可达对象和不可达对象，分别做好标记</p><p>接着会扫描内存，找到不可达对象，清除他们</p><h3 id="分代垃圾回收" tabindex="-1">分代垃圾回收 <a class="header-anchor" href="#分代垃圾回收" aria-label="Permalink to &quot;分代垃圾回收&quot;">​</a></h3><p>v8引擎对此又进行你进一步的优化，即为分代垃圾回收，他将内存分为两代</p><ul><li>新生代：存放新创建的对象，生命周期短。</li><li>老生代：存放存活时间较长的对象。</li></ul><h4 id="新生代回收" tabindex="-1">新生代回收 <a class="header-anchor" href="#新生代回收" aria-label="Permalink to &quot;新生代回收&quot;">​</a></h4><p>新生代分为两个半空间（From 和 To），每次只使用其中一个。</p><ul><li>从根对象开始，标记 From 空间中的存活对象。</li><li>把存活对象复制到 To 空间。</li><li>清空 From 空间。</li><li>交换 From 和 To 空间的角色。</li></ul><p>特点：速度快，但空间利用率低（一半空间闲置）。</p><p>如果一块内存经过多次新生代回收还存活，则会转移至老生代</p><h4 id="老生代回收" tabindex="-1">老生代回收 <a class="header-anchor" href="#老生代回收" aria-label="Permalink to &quot;老生代回收&quot;">​</a></h4><p>使用标记清除法</p><ul><li>标记所有可达对象。</li><li>清除不可达对象。</li><li>偶尔整理内存碎片，把存活对象移到一起。 特点：适合处理长期存活的对象，但耗时较长。</li></ul><p>同时v8也进行了进一步优化</p><ul><li>增量标记：老生代回收耗时长，V8 将标记过程拆分为小块，穿插在 JavaScript 执行中，避免长时间暂停。</li><li>惰性清理：清除阶段不一次性完成，而是按需清理，进一步减少停顿。</li></ul><h2 id="垃圾回收的影响" tabindex="-1">垃圾回收的影响 <a class="header-anchor" href="#垃圾回收的影响" aria-label="Permalink to &quot;垃圾回收的影响&quot;">​</a></h2><ul><li>每次执行gc时，由于js的单线程限制，js的执行会被暂停</li><li>频繁gc可能导致内存不连续，影响后续分配效率。</li><li>GC 触发时机不可控，可能在关键时刻（如动画或事件处理）导致卡顿。</li></ul>',26)]))}const m=l(o,[["render",r]]);export{p as __pageData,m as default};
