# 垃圾回收
javascript垃圾回收的核心是标记清除
## 常见的GC算法
### 引用计数法
由对象自己记录下有多少程序在引用自己，当引用数清零的时候，即意味着GC回收

优点
* 即时回收，当引用为0时就会把对象连向空闲链表等待回收；
* 不用遍历堆区活动对象和非活动对象
缺点
* 无法解决循环引用；（两个对象或多个形成引用环，引用计数不为0故无法回收）
* 每个对象都要有引用计数器，内存开销大；
> 该算法已经逐渐被 ‘标记-清除’ 算法替代，在V8引擎里面，使用最多的就是 标记-清除算法
### 标记清除法-这也是js现在使用的算法
垃圾回收器从一些固定的“根”开始，比如全局对象（在浏览器中是 window，在 Node.js 中是 global）、当前执行上下文的变量等，通过区分引用链（比如对象的属性、数组的元素）能访问到的对象，分为可达对象和不可达对象，分别做好标记

接着会扫描内存，找到不可达对象，清除他们

### 分代垃圾回收
v8引擎对此又进行你进一步的优化，即为分代垃圾回收，他将内存分为两代
* 新生代：存放新创建的对象，生命周期短。
* 老生代：存放存活时间较长的对象。

#### 新生代回收
新生代分为两个半空间（From 和 To），每次只使用其中一个。
* 从根对象开始，标记 From 空间中的存活对象。
* 把存活对象复制到 To 空间。
* 清空 From 空间。
* 交换 From 和 To 空间的角色。

特点：速度快，但空间利用率低（一半空间闲置）。

如果一块内存经过多次新生代回收还存活，则会转移至老生代
#### 老生代回收
使用标记清除法
* 标记所有可达对象。
* 清除不可达对象。
* 偶尔整理内存碎片，把存活对象移到一起。
特点：适合处理长期存活的对象，但耗时较长。

同时v8也进行了进一步优化
* 增量标记：老生代回收耗时长，V8 将标记过程拆分为小块，穿插在 JavaScript 执行中，避免长时间暂停。
* 惰性清理：清除阶段不一次性完成，而是按需清理，进一步减少停顿。

## 垃圾回收的影响
* 每次执行gc时，由于js的单线程限制，js的执行会被暂停
* 频繁gc可能导致内存不连续，影响后续分配效率。
* GC 触发时机不可控，可能在关键时刻（如动画或事件处理）导致卡顿。